// DOC: https://threejs.org/docs/#TSL

- scene bg color not working?

- prompt from twitter guy for TSL!!

https://www.instagram.com/p/DQ3_7AHiIk2/?img_index=1

- https://x.com/mingjyunhung/status/1995855482171654479 (be sure to credit)
- https://x.com/Andersonmancini/status/1996162855842746483
- https://x.com/makio64/status/1996170137901359503

ICE: https://x.com/cmzw_/status/1985719540471488863

- CODE CLEANUP: less composition in classes, specifically passing of arguments. things should live more on their own or be exposed more easily

https://claude.ai/chat/94a275fc-87a9-47e8-bd13-0036bd9c20a6


- volumetrics:
https://www.reddit.com/r/GraphicsProgramming/comments/1aqj2dc/volumetric_fog_god_rays/

- refraction: https://threejs.org/examples/?q=water#webgpu_refraction

- water https://threejs.org/examples/?q=water#webgpu_water
- https://discourse.threejs.org/t/make-high-performance-games-with-water-surface-simulations-with-water-bodies/74113/2
^ find out whats most performant

- MSDF text
    - https://webgpu.github.io/webgpu-samples/?sample=textRenderingMsdf
    - https://github.com/leochocolat/three-msdf-text-utils?tab=readme-ov-file

- Render normals, worldposition

- mouse movement

- Post pro: abstract functionality
    - Need to export world from depth 

- Grid w compute shader

- Post pro
    - Volumetric lighting
    - Bloom
    - Data moshing
        - https://ompuco.wordpress.com/2018/03/29/creating-your-own-datamosh-effect/
    


- Lighting
    - Custom set-up with MRO textures?

- Offscreen rendering?
    - https://claude.ai/chat/f4145cd5-a15b-4ee7-9c62-de5fb3b9cccf
    - https://github.com/pmndrs/react-three-offscreen/blob/main/src/render.ts
    


- Port over grid
    - Make screen adaptive + mobile version

- Particle system


POST PRO

The performant way to disable is: don’t compile / don’t run the effect at all
In your current architecture you already have the tools to do this:
Per‑scene graph build:
When a scene (or transition) changes, you call rebuildGraph() and build a different node graph:
If the scene needs SSAO, build a graph (or pipeline) that includes SSAO.
If it doesn’t, build a graph that simply never wires in that code.
Result: the SSAO code is not in the compiled shader for that scene combo.
Per‑scene / per‑pipeline passes:
For truly heavy stuff, you can keep them as separate fullscreen passes:
Scene A: renderScene → SSAO pass → colorGrading pass → transition pass
Scene B: renderScene → colorGrading pass → transition pass
You simply don’t call renderer.render for the SSAO mesh when the scene doesn’t use SSAO, so there’s zero AO cost.
Practical rule of thumb
Cheap / mid‑weight screen‑space effects (grade, vignette, basic distortion, simple outlines):
Keep them in your single Option‑A fullscreen pass, and enable/disable by changing the graph on scene switch (so unused effects don’t even compile).
Mega effects (multi‑tap DOF, SSAO, multi‑stage bloom, very dense sampling):
Give them:
Their own node material(s), and
Their own fullscreen pass(es),
and only:
Create those materials once (on scene setup / transition setup, not per frame), and
Render those passes only for scenes that use them.
This way Option A is still your backbone (one main post pass), and your heavy screen‑space effects are completely absent—not just “if’d off”—for scenes that don’t need them.